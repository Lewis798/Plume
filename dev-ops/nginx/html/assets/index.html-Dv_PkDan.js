import{_ as t,c as o,e as a,o as i}from"./app-2cMreD1z.js";const p={};function n(r,e){return i(),o("div",null,e[0]||(e[0]=[a('<h3 id="_9-1-composition-复合" tabindex="-1"><a class="header-anchor" href="#_9-1-composition-复合"><span>9.1 Composition 复合</span></a></h3><p>类似于c中结构里有结构——class里有class</p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-02/image-20230801093748678.png" alt="image-20230801093748678" style="zoom:67%;"><p><code>deque</code> 是一个已经存在的功能很多的类（两头进出的队列）；利用<code>deque</code>的功能来实现<code>queue</code>的多种操作</p><blockquote><p>该例只是复合的一种情况——设计模式 <strong>Adapter</strong></p></blockquote><h4 id="_9-1-1-复合下的构造和析构" tabindex="-1"><a class="header-anchor" href="#_9-1-1-复合下的构造和析构"><span>9.1.1 复合下的构造和析构</span></a></h4><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801095529359.png" alt="image-20230801095529359" style="zoom:67%;"><ul><li><p>构造是<mark>由内而外</mark></p><p>Container 的构造函数，编译器会自动先调用 Component 的 default 构造函数，再执行自己</p><blockquote><p>注意如果要调用 Component 的其他构造函数需要自己写出来</p><p><code>Container::Container(…): Component() { … };</code></p></blockquote></li><li><p>析构是<mark>由外而内</mark></p><p>Container 的析构函数会先执行自己，之后编译器调用 Component 的析构函数</p></li></ul><h3 id="_9-2-delegation-委托" tabindex="-1"><a class="header-anchor" href="#_9-2-delegation-委托"><span>9.2 Delegation 委托</span></a></h3><p>委托就是 Composition by reference；即通过指针把任务委托给另一个类</p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801101359560.png" style="zoom:50%;"><p>复合中，内部和外部是一起出现的；而委托是不同步的</p><blockquote><p>这是一个著名的设计模式——<strong>pimpl</strong> (pointer to implementation) 或者叫 “编译防火墙”</p><ul><li><p>右边怎么变动都不会影响左边</p></li><li><p>reference counting 多个指针共享一个 “Hello”；但当a要改变内容时， 系统会单独复制一份出来给a来改，b和c依然在共享</p><img src="https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801101907977.png" alt="image-20230801101907977" style="zoom:67%;"></li></ul></blockquote>',13)]))}const s=t(p,[["render",n],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/cpp/j1o7j4cp/","title":"复合 委托","lang":"zh-CN","frontmatter":{"title":"复合 委托","createTime":"2024/12/07 23:43:30","permalink":"/cpp/j1o7j4cp/","description":"9.1 Composition 复合 类似于c中结构里有结构——class里有class image-20230801093748678 deque 是一个已经存在的功能很多的类（两头进出的队列）；利用deque的功能来实现queue的多种操作 该例只是复合的一种情况——设计模式 Adapter 9.1.1 复合下的构造和析构 image-202308...","head":[["meta",{"property":"og:url","content":"https://plume.pookie.top/cpp/j1o7j4cp/"}],["meta",{"property":"og:site_name","content":"Plume Notes"}],["meta",{"property":"og:title","content":"复合 委托"}],["meta",{"property":"og:description","content":"9.1 Composition 复合 类似于c中结构里有结构——class里有class image-20230801093748678 deque 是一个已经存在的功能很多的类（两头进出的队列）；利用deque的功能来实现queue的多种操作 该例只是复合的一种情况——设计模式 Adapter 9.1.1 复合下的构造和析构 image-202308..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T15:52:20.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T15:52:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"复合 委托\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-07T15:52:20.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":1.25,"words":374},"git":{"updatedTime":1733586740000,"contributors":[{"name":"Lewis798","email":"QA2160073500@outlook.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Lewis798?v=4","url":"https://github.com/Lewis798"}]},"autoDesc":true,"filePathRelative":"notes/C++/1.面向对象高级开发 Part1/复合 委托.md","bulletin":false}');export{s as comp,m as data};
