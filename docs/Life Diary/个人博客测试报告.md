---
title: 个人博客系统测试报告
createTime: 2025/08/17 19:30:26
permalink: /article/n2wlu35m/
tags:
  - Life Diary
cover: https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250818093421065.png
---




# 个人博客测试报告
本次测试覆盖了系统的核心功能，包括==手工测试、Web 自动化用例执行以及性能压力测试==。重点验证了用户登录、文章列表，文章编辑等功能的稳定性，并收集了性能指标作为优化依据。<!-- more -->

### 一、项目背景

​     个人的博客系统使用的是SSM框架搭建的，博客系统由五个页面构成：用户登录页面，博客列表页面，博客详情页面，博客编辑页面，博客发布页，为了验证个人博客系统的功能是否正常，现在对博客系统进行手动和自动化测试，

> **主要功能：登录、博客文章列表、发布博客、删除博客、注销退出登录**

### 二、项目测试

> **测试方向主要为功能测试，界面测试，性能测试，易用性测试，安全测试，兼容性测试等6个方面进行设计测试，个人实现的博客系统是一个web网址，我们主要对核心功能进行测试**

#### 1、测试用例思维导图



<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816145415459.png" alt="image-20250816145408255" style="zoom:50%;" />



<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816145553804.png" alt="自动化测试思维导图" style="zoom:50%;" />

#### 2、登录页面测试

> **测试场景一**：：输入正确的用户名和密码点击提交
>
> 预期结果：登录成功，跳转到博客主页
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816150511183.png" alt="image-20250816150510490" style="zoom:50%;" />
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816150448764.png" alt="image-20250816150447976" style="zoom:50%;" />
>
>  实际结果：与预期结果一致。登录成功，跳转到博客主页面



> **测试场景二**：输入正确的用户名和错误的密码
>
> 预测结果：弹窗提示密码错误！
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816150737056.png" alt="image-20250816150736325" style="zoom:50%;" />
>
> 实际结果：与预期结果一致。弹窗提示密码错误

> **测试场景三**：输入错误的用户名和正确的密码
>
> 预期结果：弹窗提示用户不存在
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816150936837.png" alt="image-20250816150936314" style="zoom:50%;" />
>
>  实际结果：与预期结果一致。弹窗提示用户不存在

> **测试场景四**：输入时账号或密码为空
>
> 预期结果：弹窗提示账号或密码不能为空
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816151232426.png" alt="image-20250816151231877" style="zoom:50%;" />
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816151325819.png" alt="image-20250816151325346" style="zoom:50%;" />
>
> 实际结果：与预期结果一致。弹窗提示账号或密码不能为空

#### 3、博客列表页面测试

> **测试场景一**：点击菜单栏的“写博客”
>
> 预期结果：页面跳转到博客编辑页，用户可以编写博客
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816152027360.png" alt="image-20250816152027034" style="zoom:50%;" />
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816152048495.png" alt="image-20250816152047872" style="zoom:50%;" />
>
> 实际结果：与预期结果一致。页面正常跳转到编辑页面

> **测试用例二**：输入标题和内容，点击“发布文章”按钮可正常发布博客，在博客首页查看到。
>
> 预期结果：成功发布博客，在首页可看到发布的博客。
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816152240910.png" alt="image-20250816152240232" style="zoom:50%;" />
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816152310108.png" alt="image-20250816152309838" style="zoom:50%;" />
>
> 实际结果：与预期结果一致。可查看到发布的博客。

> **测试场景三**：输入标题和不输入内容，点击“发布文章”按钮可不能正常发布博客，在博客主页无法查看到。
>
> 预期结果：弹出空白提示框，在首页看不到相关博客
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816152833598.png" alt="image-20250816152833033" style="zoom:50%;" />
>
> 实际结果：弹出空白提示框，在首页看不到相关博客

> **测试场景四**：点击首页的任意一个博客下方的“查看全文”
>
> 预期结果：页面跳转到博客详情页，可查看博客内容
>
> ![image-20250816153032343](https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153032675.png)
>
> ![image-20250816153045128](https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153045449.png)
>
> 实际结果：与预期结果一致。页面正常跳转到博客详情界面。



#### 4、注销测试

> **测试场景**：点击菜单栏的“注销”
>
> 预期结果：页面跳转到登录界面，用户名和密码被清空，用户可重新登录。![image-20250816153333145](https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153333478.png)
>
> ![image-20250816153255872](https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153256677.png)
>
> 实际结果：与预期结果一致。页面正常跳转到登录界面。



#### 5、博客详情页测试

> **测试场景一**：点击“编辑”按钮
>
> 预期结果：进入博客更新页面，可对之前的内容进行编辑，编辑完成后点击更新文章，可在首页看到更新后的文章。
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153555513.png" alt="image-20250816153555225" style="zoom:50%;" />
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153636742.png" alt="image-20250816153636214" style="zoom:50%;" />
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153706870.png" alt="image-20250816153706673" style="zoom:50%;" />
>
> 实际结果：与预期结果一致。更新内容后可在首页查看到更新后的博客



> **测试场景二**：点击“删除”按钮
>
> 预期结果：博客被成功删除，在首页找不到此博客
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816153815088.png" alt="image-20250816153814664" style="zoom:50%;" />
>
> 实际结果：与预期结果一致。且弹窗提示用户确定删除。



> **测试场景三**：在zhangsan的账号下，我们可以看到是无法编辑和删除lisi用户发布的这篇博客的，在lisi账号下可正常操作。
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816154109363.png" alt="image-20250816154108939" style="zoom:50%;" />
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250816154036266.png" alt="image-20250816154036023" style="zoom:50%;" />



### 三、web自动化测试

> 在进行 Web 自动化测试之前，需要先安装两个关键工具：
>
> 1. **Selenium 库**
>     Selenium 是一款功能强大的 Web 自动化测试工具，提供了丰富的 API 方法，能够模拟用户操作，实现对浏览器的自动化控制与测试。
> 2. **WebDriver Manager 驱动管理工具**
>     在使用 Chrome 浏览器进行自动化测试时，通常需要安装对应的 **ChromeDriver**。如果手动维护，每次 Chrome 浏览器更新都需要同步更新驱动，比较繁琐。
>     借助 `webdriver-manager`，可以自动下载并管理与当前 Chrome 版本匹配的 **ChromeDriver**，确保测试脚本能稳定运行，而无需手动更新驱动。

**注意**在创建项目之后我们需要去检查相关环境是否配置好,具体路径为**File → Settings（Mac 上是 PyCharm → Preferences） → Project: 你的项目名 → Python Interpreter**

##### 1.1 项目目录结构和文件说明

```python
BlogAutoTest/                     # 自动化测试项目根目录
├─ common/                        # 公共工具/配置
│   ├─ __init__.py
│   └─ Utils.py                   # 提取公共配置与方法（如创建驱动对象、访问URL、截图等）
├─ images/                        # 存放截图
│   └─ 2025-08-16/                # 以日期命名的截图文件夹
├─ tests/                         # 存放测试用例（测试代码逻辑分层）
│   ├─ __init__.py
│   ├─ BlogLoginTest.py           # 博客登录页相关测试用例
│   ├─ BlogListTest.py            # 博客首页相关测试用例
│   ├─ BlogDetailTest.py          # 博客详情页相关测试用例
│   ├─ BlogEditTest.py            # 博客编辑页相关测试用例
│   └─ RunTest.py                 # 用于统一执行测试用例（可能集成 unittest/pytest 入口）
```

##### 1.2 创建驱动对象

> **创建一个全局可复用的浏览器驱动对象，统一管理浏览器的启动、关闭、截图等操作。**

`utils.py`**集中管理浏览器驱动和公共工具方法**，为测试用例提供统一的浏览器入口和复用功能。

```python
import os
import sys
import datetime
from selenium import webdriver
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service


class Driver:
    driver = ""

    def __init__(self):
        options = webdriver.ChromeOptions()
        # 这里可以添加配置，比如无头模式：
        # options.add_argument("--headless")
        self.driver = webdriver.Chrome(
            service=Service(ChromeDriverManager().install()), options=options
        )
        # 添加一个隐式等待，预防代码执行速度比页面渲染加载快，报错
        self.driver.implicitly_wait(2)  # 隐式等待2秒，生命周期是整个查找过程

    # 截图函数
    def GetScreeShot(self):
        # 日期目录名
        driname = datetime.datetime.now().strftime("%Y-%m-%d")

        # 拼接保存路径（../images/日期），递归创建目录
        save_dir = os.path.join("..", "images", driname)
        os.makedirs(save_dir, exist_ok=True)

        # 截图的图片名称要加上调用者函数名+时间戳
        filename = (
            sys._getframe().f_back.f_code.co_name
            + "-"
            + datetime.datetime.now().strftime("%Y-%m-%d-%H%M%S")
            + ".png"
        )

        # 保存截图
        self.driver.save_screenshot(os.path.join(save_dir, filename))


BlogDriver = Driver()  # 使用Driver类创建一个类驱动对象
```

`RunTest.py`**用来测试不同功能测试文件里面的测试函数（主函数的入口)**

```python
#导入测试用例模块
from BlogAutoTest.tests import BlogLoginTest
from BlogAutoTest.tests import BlogListTest
from BlogAutoTest.tests import BlogDetailTest
from BlogAutoTest.tests import BlogEditTest
from BlogAutoTest.common.Utils import BlogDriver
from BlogAutoTest.tests.BlogDetailTest import BlogDetail

# 程序的入口
if __name__ == "__main__":
    
    # 程序具体执行
```

##### 1.3、博客自动化登录测试

①创建一个文件名为：BlogLoginTest.py,里面存在测试登录的函数（包括成功登录和异常登录）

②引入名为common的python包，包上common里面的Utils.py文件

③创建一个名为BlogLogin的类，方法：`BlogSucText()`（成功）、`BlogFailText()`（失败）

④重点注意清空输入框的内容后才能再次输入用户名及密码进行登录

⑤（测试内容）：**成功用例**：打开页面 → 输入正确账号密码 → 提交 → 等待昵称元素出现 → 截图 → 断言昵称非空。

​                     **失败用例**：打开页面 → 输入错误账号密码 → 提交 → 等待 alert → 对比提示文案 → `accept()` → 截图。

⑥在RunTest.py里面主要函数调用的顺序，想要看到其他页面的正常效果必须先登录成功

`BlogLoginTest.py`

```python
import time
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys

from BlogAutoTest.common.Utils import BlogDriver


class BlogLogin:
    def __init__(self):
        self.driver = BlogDriver.driver
        self.url = "http://8.137.19.140:9090/blog_login.html"
        self.wait = WebDriverWait(self.driver, 5)
        self.driver.get(self.url)
        # 等待登录页关键元素，确保页面加载完成
        self.wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "#username")))
        self.wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "#password")))
        self.wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "#submit")))
        print("[初始化] 已打开登录页：", self.url)

    # ========== 工具方法 ==========
    def _open_login(self):
        """统一回到登录页，比 back() 更稳，并等到输入框可用"""
        self.driver.get(self.url)
        self.wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "#username")))
        self.wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "#password")))
        self.wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "#submit")))

    def _type_safely(self, by, selector, text, label=""):
        """
        稳定输入：等待→点击→强清(Ctrl+A/Del)→分次输入→校验→必要时JS兜底
        """
        el = self.wait.until(EC.visibility_of_element_located((by, selector)))
        self.wait.until(EC.element_to_be_clickable((by, selector)))

        # 点击并强清
        el.click()
        time.sleep(0.05)
        try:
            el.send_keys(Keys.CONTROL, "a")
            el.send_keys(Keys.DELETE)
        except Exception:
            pass
        try:
            el.clear()
        except Exception:
            pass

        # 分次输入（避免一次性丢字符）
        if text:
            for ch in text:
                el.send_keys(ch)
                time.sleep(0.02)  # 轻微节流，防止前端拦截/丢字符

        # 校验并最多重试2次
        def _val():
            try:
                return (el.get_attribute("value") or "")
            except Exception:
                return ""

        val = _val()
        retries = 2
        while val != text and retries > 0:
            try:
                el.send_keys(Keys.CONTROL, "a")
                el.send_keys(Keys.DELETE)
            except Exception:
                pass
            if text:
                for ch in text:
                    el.send_keys(ch)
                    time.sleep(0.02)
            val = _val()
            retries -= 1

        # 仍不一致则用 JS 兜底
        if val != text:
            try:
                self.driver.execute_script(
                    "arguments[0].value = arguments[1]; "
                    "arguments[0].dispatchEvent(new Event('input'));",
                    el, text
                )
                val = _val()
            except Exception:
                pass

        print(f"[输入校验] {label} -> 期望: '{text}' 实际: '{val}'")
        assert val == text, f"{label} 未成功输入，实际值: '{val}'"

    def _fill_and_submit(self, username: str, password: str):
        """输入账号密码并提交（带强校验）"""
        self._type_safely(By.CSS_SELECTOR, "#username", username, label="用户名")
        self._type_safely(By.CSS_SELECTOR, "#password", password, label="密码")
        submit_btn = self.wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, "#submit")))
        submit_btn.click()
        time.sleep(0.3)  # 给前端/接口一点反应时间

    def _get_alert_text_if_any(self, timeout=8):
        """等待并返回 alert 文本；无 alert 则返回 (None, None)"""
        try:
            alert = WebDriverWait(self.driver, timeout).until(EC.alert_is_present())
            return alert.text, alert
        except Exception:
            return None, None

    # ========== 成功登录用例 ==========
    def BlogSucText(self):
        """
        成功登录博客页面的函数
        """
        print("\n=== 用例提示：正确账号密码，期望登录成功 ===")
        self._open_login()

        print("[步骤] 输入账号/密码：zhangsan/123456 并点击登录")
        self._fill_and_submit("zhangsan", "123456")

        # 等待登录成功后页面的关键元素（昵称）出现
        nickname_el = self.wait.until(EC.visibility_of_element_located(
            (By.CSS_SELECTOR, "body > div.container > div.left > div > h3")
        ))

        # 登录成功截图
        BlogDriver.GetScreeShot()

        # 读取页面信息
        name = nickname_el.text
        article = self.driver.find_element(
            By.CSS_SELECTOR,
            "body > div.container > div.left > div > div:nth-child(4) > span:nth-child(1)"
        ).text
        classification = self.driver.find_element(
            By.CSS_SELECTOR,
            "body > div.container > div.left > div > div:nth-child(4) > span:nth-child(2)"
        ).text

        # 基本断言
        assert name != "", "登录成功后昵称为空，疑似未成功登录"

        print(f"[结果] 昵称：{name}")
        print(f"[结果] 文章：{article}")
        print(f"[结果] 分类：{classification}")

    # ========== 失败登录用例 ==========
    def BlogFailText(self):
        """
        错误登录博客的函数
        逐条执行多组失败用例：每条有清晰提示与断言，并会截图
        """
        print("\n=== 用例提示：错误账号/密码场景，期望登录失败并弹出提示 ===")

        # 请按你后端的真实提示文案调整 expect
        fail_cases = [
            # (username, password, 期望alert文案, 用例提示)
            ("lisi", "123", "密码错误", "密码错误"),
            # ("lis", "123456", "用户不存在", "用户不存在"),
            # ("zhangsan", "123", "密码错误", "密码错误"),
            # ("", "", "请输入用户名和密码", "账号或密码不能为空"),
        ]

        for idx, (u, p, expect, hint) in enumerate(fail_cases, start=1):
            print(f"\n--- 失败用例 {idx}：{hint} ---")
            self._open_login()
            print(f"[步骤] 输入账号/密码：{u}/{p} 并点击登录")
            self._fill_and_submit(u, p)

            # 提交后先截图（方便定位）
            BlogDriver.GetScreeShot()

            # 等待 alert（最长 8 秒）
            text, alert = self._get_alert_text_if_any(timeout=8)
            print("[提示] 捕获到的 Alert 文本：", text)

            assert text is not None, f"未出现错误提示（Alert），用例：{hint}"
            assert text == expect, f"提示不匹配：期望[{expect}]，实际[{text}]，用例：{hint}"

            # 关闭 alert
            alert.accept()
            print("[步骤] 已关闭错误提示弹窗")

        print("\n[结果] 所有失败用例均已按预期触发并通过断言")
```

> **亮点**：在实际运行代码过程中，我遇到浏览器其他弹框时，密码输入不上的问题。解决方案如下：“**稳输入**”实现：输入前确保可见&可点、`Ctrl+A/Delete` 强清、分次输入并校验；失败再重试，最后用 JS 兜底写值。
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817085411776.png" alt="相应的输入校验" style="zoom:50%;" />

**测试用例添加**使用元素集合的办法，把各种错误场景写在一个列表里，每个场景是一条 tuple。tuple 里存：`(用户名, 密码, 期望提示文本, 用例说明)`，再使用遍历`for idx, (u, p, expect, hint) in enumerate(fail_cases, start=1):` 遍历所有用例

`用例代码`

```python
fail_cases = [
    # (username, password, 期望alert文案, 用例提示)
    ("lisi", "123", "密码错误", "密码错误"),
    # ("lis", "123456", "用户不存在", "用户不存在"),
    # ("zhangsan", "123", "密码错误", "密码错误"),
    # ("", "", "请输入用户名和密码", "账号或密码不能为空"),
]
```

`RunTest.py`

```python
from BlogAutoTest.tests import BlogLoginTest
from BlogAutoTest.tests import BlogListTest
from BlogAutoTest.tests import BlogDetailTest
from BlogAutoTest.tests import BlogEditTest
from BlogAutoTest.common.Utils import BlogDriver
from BlogAutoTest.tests.BlogDetailTest import BlogDetail


if __name__ == "__main__":

    blog_login_instance = BlogLoginTest.BlogLogin()
    blog_login_instance.BlogSucText()
    blog_login_instance.BlogFailText()
    blog_list_instance = BlogListTest.BlogList()
```



**运行结果打印截图**：

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817090446670.png" style="zoom:50%;" />

**相关保存成功**：

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817090655884.png" style="zoom:50%;" />





##### 1.4、博客列表页自动化测试

BlogListTest.py 的整体实现逻辑如下

- ① 创建一个文件名为：**BlogListTest.py**，里面存在测试列表页的函数（包括登录状态下的列表页测试、未登录状态下的列表页测试、以及退出登录测试）。

  ② 引入名为 **common** 的 python 包，使用其中的 **Utils.py** 文件：
   `from BlogAutoTest.common.Utils import BlogDriver`。

  ③ 创建一个名为 **BlogList** 的类，方法：`BlogLoginListTest()`（登录状态下的列表页测试）、`NotBlogLoginListTest()`（未登录状态下的列表页测试）、`QuitBlogLoginListTest()`（退出登录测试）。

  ④ 重点注意在涉及登录的场景里，需要先清空输入框的内容，再输入用户名和密码，避免数据残留导致异常。

  ⑤ （测试内容）：

  -    **登录状态下用例**：进入列表页 → 检查博客标题、发布时间、内容、查看全文按钮是否存在 → 检查左侧用户基本信息（昵称、文章数、分              类数） → 检查博客数量是否大于 0 → 截图。
  -    **未登录状态下用例**：直接访问列表页 → 验证页面能否正常打开 → 截图。
  -    **退出登录用例**：点击退出按钮 → 验证页面跳转到登录页 → 检查页面标题和 URL 是否正确 → 验证用户名和密码输入框为空 → 截图。

  ⑥ 在 **RunTest.py** 里函数调用的顺序必须先执行登录成功用例（BlogLogin.BlogSucText()），确保处于登录状态，然后再执行 BlogLoginListTest、QuitBlogLoginListTest 和 NotBlogLoginListTest，因为大多数页面依赖登录态才能展示正常效果。



`BlogListTest.py`

```python
import time
from selenium.webdriver.common.by import By
from BlogAutoTest.common.Utils import BlogDriver


class BlogList:
    driver = ""
    url = ""
    def __init__(self):
        self.driver = BlogDriver.driver
        self.url = "http://8.137.19.140:9090/blog_list.html"
        self.driver.get(self.url)

    def BlogLoginListTest(self):#登路状态下
        #检查一下博客的标题是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.right > div:nth-child(1) > div.title")
        #检查一下发布博客的时间是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.right > div:nth-child(1) > div.date")
        #检查一下博客的内容是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.right > div:nth-child(1) > div.desc")
        #检查一下博客列表页的查看全文按钮是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.right > div:nth-child(1) > a")
        #检查一下用户基本信息的昵称是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.left > div > h3")
        #检查一下用户基本信息的文章是否存在
        self.driver.find_element(By.CSS_SELECTOR, "body > div.container > div.left > div > div:nth-child(4) > span:nth-child(1)")
        #检查一下用户基本信息的分类是否存在
        self.driver.find_element(By.CSS_SELECTOR, "body > div.container > div.left > div > div:nth-child(4) > span:nth-child(2)")
        #检查一下博客数量是否为0，不为就就通过
        Blognum = self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.left > div > div:nth-child(5) > span:nth-child(1)").text
        print(Blognum)
        assert Blognum != 0
        BlogDriver.GetScreeShot()
        # self.driver.quit()

    def NotBlogLoginListTest(self):  #未登录状态下
        # # 找到用户命名输入框和密码输入框把里面的内容清空
        # self.driver.find_element(By.CSS_SELECTOR, "#username").clear()
        # self.driver.find_element(By.CSS_SELECTOR, "#password").clear()
        self.driver.get("http://8.137.19.140:9090/blog_list.html")
        time.sleep(2)
        BlogDriver.GetScreeShot()
        self.driver.find_element(By.CSS_SELECTOR, "body > div.container > div.right > div:nth-child(1) > div.title")


    def QuitBlogLoginListText(self):  # 登录博客状态下测试退出
        #点击退出按钮
        self.driver.find_element(By.CSS_SELECTOR, "body > div.nav > a:nth-child(6)").click()
        BlogDriver.GetScreeShot()
        #判断一下退出后的页面url和页面的标题
        Quittitle = self.driver.title
        QuitUrl = self.driver.current_url
        print(Quittitle)
        print(QuitUrl)
        assert Quittitle == "博客登录页"
        assert QuitUrl == "http://8.137.19.140:9090/blog_login.html"
        #判断一下账号输入框和密码输入框的内容是否为空
        Quitusername = self.driver.find_element(By.CSS_SELECTOR,"#username").text
        Quitpassword = self.driver.find_element(By.CSS_SELECTOR,"#password").text
        print("Quitusername"+Quitusername)
        print("Quitpassword"+Quitpassword)
        assert Quitusername == ""
        assert Quitpassword == ""
```

`Runtest.py`

```python
if __name__ == "__main__":

    blog_login_instance = BlogLoginTest.BlogLogin()
    blog_login_instance.BlogSucText()
    # blog_login_instance.BlogFailText()
    blog_list_instance = BlogListTest.BlogList()
    #登录状态下测试博客列表页
    blog_list_instance.BlogLoginListTest()
    #退出博客登录
    blog_list_instance.QuitBlogLoginListText()
    #未登录状态下测试博客列表页
    blog_list_instance.NotBlogLoginListTest()
    BlogDriver.driver.quit()
```

**运行结果打印截图：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817093318176.png" alt="image-20250817093318032" style="zoom:50%;" />





##### 1.5、博客详情页的自动化测试

① 创建一个名为 **BlogDetail** 的类，把 driver 和 url 成员变量以及函数的实现方法定义在里面：

- 登录状态下测试详情页：`BlogLoginDetailTest`
- 登录状态下删除博客：`DeleteBlogLoginDetailTest`
- 未登录状态下访问详情页：`NotBlogLoginDetailTest`

② 重点注意：在涉及登录的场景下，需要先清空输入框的内容，再输入用户名和密码进行登录，避免数据残留影响结果。

③ （测试内容）：检查博客标题、发布时间、博客内容、左侧用户基本信息（昵称、文章、分类）、以及编辑和删除按钮等关键元素是否存在。

④ 在 **RunTest.py** 里面主要函数调用的顺序：想要看到其他页面的正常效果必须先调用登录成功用例，确保系统处于登录状态，然后再调用 BlogDetail 相关的测试方法。

`BlogDetailTest.py`

```python
import time
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from BlogAutoTest.common.Utils import BlogDriver


class BlogDetail:
    driver = ""
    url = ""
    def __init__(self):
        self.driver = BlogDriver.driver
        #一篇博客的url
        self.url = "http://8.137.19.140:9090/blog_detail.html?blogId=162407"
        self.driver.get(self.url)

    def BlogLoginDetailTest(self):
        # 检查一下博客的标题是否存在
        self.driver.find_element(By.CSS_SELECTOR, "body > div.container > div.right > div > div.title")
        # 检查一下发布博客的时间是否存在
        self.driver.find_element(By.CSS_SELECTOR, "body > div.container > div.right > div > div.date")
        # 检查一下博客的内容是否存在
        self.driver.find_element(By.CSS_SELECTOR, "#detail")
        # 检查一下用户基本信息的昵称是否存在
        self.driver.find_element(By.CSS_SELECTOR, "body > div.container > div.left > div > h3")
        # 检查一下用户基本信息的文章是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.left > div > div:nth-child(4) > span:nth-child(1)")
        # 检查一下用户基本信息的分类是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.left > div > div:nth-child(4) > span:nth-child(2)")
        #检查一下编辑按钮是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.right > div > div.operating > button:nth-child(1)")
        #检查一下删除按钮是否存在
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.right > div > div.operating > button:nth-child(2)")
        #添加屏幕截图
        BlogDriver.GetScreeShot()
        time.sleep(2)

    def DeleteBlogLoginDetailTest(self):
        #点击第一篇博客删除按钮
        BlogDriver.GetScreeShot()
        self.driver.find_element(By.CSS_SELECTOR,"body > div.container > div.right > div > div.operating > button:nth-child(2)").click()
        #点击删除按钮后会出现一个弹窗
        wait = WebDriverWait(self.driver,2)
        #检查弹窗是否出现
        wait.until(EC.alert_is_present())
        #找到弹窗
        alert = self.driver.switch_to.alert
        #判断一下弹窗里面的内容是否是确定删除？
        actual = alert.text
        print(actual)
        assert actual == "确定删除?"
        #点击确定删除按钮
        alert.accept()
        time.sleep(1)
        BlogDriver.GetScreeShot()
        #删除后判断一下是否返回到了博客列表页
        time.sleep(1)
        rettitle = self.driver.title
        retUrl = self.driver.current_url
        assert rettitle == "博客列表页"
        assert retUrl == "http://8.137.19.140:9090/blog_list.html"
        print("rettitle:"+rettitle)
        print("retUrl:"+retUrl)

    def NotBlogLoginDetailTest(self):
        wait = WebDriverWait(self.driver, 10)

        # 等待页面跳转到登录页（可能标题是“博客登录页”或包含“登录/登陆”字样，URL 包含 blog_login）
        wait.until(
            EC.any_of(
                EC.title_contains("登录"),
                EC.title_contains("登陆"),
                EC.url_contains("blog_login")
            )
        )

        # 截图保存
        BlogDriver.GetScreeShot()

        # 获取当前页面信息
        title = self.driver.title
        url = self.driver.current_url
        print(f"未登录访问详情页时，实际 title={title}, url={url}")

        # 断言确实跳到了登录页
        assert "登录" in title or "登陆" in title, f"期望跳转到登录页，但实际标题为: {title}"
        assert "blog_login" in url, f"期望跳转到登录页，但实际 URL 为: {url}"

        BlogDriver.GetScreeShot()
        time.sleep(2)
```

`Runtest.py`

```python
blog_login_instance = BlogLoginTest.BlogLogin()
blog_login_instance.BlogSucText()
blog_dateil_instance = BlogDetailTest.BlogDetail()
#测试登录状态下的详情页
blog_dateil_instance.BlogLoginDetailTest()
#测试登录状态下详情页删除第一篇文章
blog_dateil_instance.DeleteBlogLoginDetailTest()
#退出登录
blog_list_instance = BlogListTest.BlogList()
#退出博客登录
blog_list_instance.QuitBlogLoginListText()
blog_dateil_instance.NotBlogLoginDetailTest()

```

**删除前的博客：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817094733248.png" alt="image-20250817094732714" style="zoom:50%;" />

**删除后：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817094847305.png" alt="image-20250817094846773" style="zoom:50%;" />

**运行结果打印截图：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817094911592.png" alt="image-20250817094911415" style="zoom:50%;" />





##### 1.6、博客编辑自动化测试

① 创建一个名为 **BlogEdit** 的类，把 driver 和 url 成员变量以及函数的实现方法定义在里面：

- 登录状态下测试编辑页：`BlogLoginEditTest`
- 未登录状态下测试编辑页：`NotBlogLoginEditTest`

② 重点注意：在涉及登录的场景下，需要先清空输入框的内容，再输入用户名和密码进行登录。

③ （测试内容）：检查能否在编辑页正确输入标题、点击发布按钮后跳转到列表页，并验证新发布的博客标题是否显示在列表中；在未登录情况下无法编辑标题输入框。

④ 在 **RunTest.py** 里面主要函数调用的顺序：必须先执行登录成功用例，然后再调用 BlogEdit 相关的测试方法。



`BlogEditTest.py`

```python
import time
from selenium.webdriver.common.by import By
from BlogAutoTest.common.Utils import BlogDriver


class BlogEdit:
    driver = ""
    url = ""
    def __init__(self):
        self.driver = BlogDriver.driver
        #编辑一篇新博克页面
        self.url = "http://8.137.19.140:9090/blog_edit.html"
        self.driver.get(self.url)

    def BlogLoginEditTest(self):
        expected_title = "凡人修仙传"
        #找到标题输入框输入标题
        time.sleep(5)
        self.driver.find_element(By.CSS_SELECTOR,"#title").send_keys("凡人修仙传")
        #编辑区域的菜单栏是第三方插件，元素无法被选中，先不处理菜单栏
        #博客编辑区本来就不为空
        time.sleep(1)
        BlogDriver.GetScreeShot()
        #点击发布文章按钮
        self.driver.find_element(By.CSS_SELECTOR,"#submit").click()
        # 因为页面的跳转需要时间，代码执行的速度如果比页面渲染的速度快，就会导致找不到元素
        time.sleep(1)
        #发布文章后，会自动跳转到博客列表页，可以判断一下跳转后的url是否等于博客列表页的url
        jumpURL = self.driver.current_url
        print(jumpURL)
        assert jumpURL == "http://8.137.19.140:9090/blog_list.html"
        #判断一下博客列表页的文章标题是否是新发布的博客的给定的标题
        # ✅ 用 CSS 选择器抓所有标题，再用 Python 找到文本为“凡人修仙传”的那一个
        titles = self.driver.find_elements(By.CSS_SELECTOR, "div.right div.title")
        actual = None
        for t in titles:
            if t.text.strip() == expected_title:
                actual = t.text.strip()
                break

        print(actual)
        assert actual == expected_title, f"期望:{expected_title}, 实际:{actual}"

    def NotBlogLoginEditTest(self):  # 未登录下
        # 未登录下应当找不到标题输入框
        try:
            self.driver.find_element(By.CSS_SELECTOR, "#title").send_keys("凡人修仙传")
            raise AssertionError("未登录却能编辑标题，权限校验缺失")
        except Exception:
            print("[未登录] 页面无 #title，行为正确")
```

`Runtest.py`

```python
#博客编辑页面的测试
blog_login_instance = BlogLoginTest.BlogLogin()
blog_login_instance.BlogSucText()
blog_edit_instance = BlogEditTest.BlogEdit()
blog_edit_instance.BlogLoginEditTest()
#然后调用退出博客函数
blog_list_instance = BlogListTest.BlogList()
blog_list_instance.QuitBlogLoginListText()
#再调用未登录状态下，去测试博客编辑页
blog_edit_instance.NotBlogLoginEditTest()
```

**成功发布文章**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817103603424.png" alt="image-20250817103603225" style="zoom:50%;" />





**运行结果打印截图：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817103521645.png" alt="image-20250817103521466" style="zoom:50%;" />





#### 总结

​      编写自动化测试脚本，能够执行更加繁琐的测试用例和在一定程度上解放测试人员，避免了重复繁琐的测试过程，让测试人员有更多的精力去设计更详细的测试用例和编写性能更高的测试脚本，提高测试结果的可行度，

> 重点注意的是，不是编写了自动化测试脚本后就完全不用管了，要检查和维护这个自动化测试化脚本。自动化测试的成本包括自动测试开发成本、自动测试运行成本、自动测试维护成本和其他相关任务带来的成本，以及软件的修改带来的测试脚本部分或全部修改所增加的测试维护的开销。





### 四、使用jmeter做接口测试和性能测试

#### 4.1、接口测试

##### 4.1.1 用户登录

**使用F12打开控制台，获取接口数据**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817121639728.png" alt="image-20250817121639534" style="zoom:50%;" />

使用postman简单测试接口成功

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817122105978.png" alt="image-20250817122105813" style="zoom:50%;" />

**使用jmetert**添加线程组，及相应测试接口请求

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817130758697.png" alt="image-20250817130758509" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817132020726.png" alt="image-20250817132020506" style="zoom:50%;" />

**登录接口测试通过，在查看结果树中查看**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817132121088.png" alt="image-20250817132120872" style="zoom: 50%;" />



> **http请求默认值：**同一个系统中协议，服务器名称或IP，端口号是不会发生变化的，所以添加一个HTTP请求默认值，其他页面不用配置3个选项，运行时会自动去HTTP请求默认值里面取

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817133517760.png" alt="image-20250817133517528" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817133553597.png" alt="image-20250817133548930" style="zoom:50%;" />



##### 4.1.2 博客列表

设置好相关请求参数，但实际请求时发生错误是怎么回事呢？

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817134231632.png" alt="image-20250817134231481" style="zoom:50%;" />



<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817134439228.png" alt="image-20250817134439040" style="zoom:50%;" />

显示没有登录状态

> **原因**：因为我们的请求头里面有一个用户的登录凭证，没有加上

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817134627709.png" alt="image-20250817134627518" style="zoom:50%;" />



**接下来选择使用http请求头管理器存储用户凭证**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817134949147.png" alt="image-20250817134948943" style="zoom:50%;" />

> **但是这样写我们用户凭证的使用还是太死板，接下来我们使用到json数据提取器，将登录后的用户凭证提取出来，保存再调用**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817140632365.png" alt="image-20250817140632222" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817140709608.png" alt="image-20250817140709469" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817140512666.png" alt="image-20250817140512450" style="zoom:50%;" />

**请求成功**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817135147227.png" alt="image-20250817135147054" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817135214497.png" alt="image-20250817135214231" style="zoom:50%;" />

##### 4.1.3、用户信息

>  **注意**：**json提取器会重复提取data，得把json提取器放到登录页的子路径下，只让他提取登录页的data**
>
> <img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817142454805.png" alt="image-20250817142454563" style="zoom:50%;" />

**用户信息提取成功**：

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817142604841.png" alt="image-20250817142604650" style="zoom:50%;" />



##### 4.1.4、博客详情页

**第一步：先找到博客id，我们可以使用json提取器。同上面操作**

先找到id提取路径：

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817143413065.png" alt="image-20250817143412882" style="zoom:50%;" />

使用json提取器进行提取保存

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817143535017.png" alt="image-20250817143534830" style="zoom:50%;" />



##### 4.1.5 添加博客

**如下图添加博客，但是出现错误。是什么原因呢**



<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817145309723.png" alt="image-20250817145309508" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817145339704.png" alt="image-20250817145339513" style="zoom:50%;" />

**原因如下：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817145632730.png" alt="image-20250817145632525" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817145719784.png" alt="image-20250817145719555" style="zoom:50%;" />

**改正：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817150051492.png" alt="image-20250817150051284" style="zoom:50%;" />

文章成功发布

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817150122977.png" alt="image-20250817150122805" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817150146581.png" alt="image-20250817150146315" style="zoom:50%;" />

#### 4.2 断言

> **开启多线程(虚拟用户的数量增加)我们不可能一个一个去查看结果的反馈是否符合我们的预期，可以看到添加了JSON断言后，判断*测试是否成功**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817150818363.png" alt="image-20250817150818189" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817151303449.png" alt="image-20250817151303225" style="zoom:50%;" />

**正则匹配的语法：https://www.runoob.com/regexp/regexp-syntax.html**



**日志查看**新版jmeter没有小黄色感叹哈，可以这样打开

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817152813620.png" alt="image-20250817152813416" style="zoom:50%;" />

**聚合报告查看：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817153255269.png" alt="image-20250817153255004" style="zoom:50%;" />



**csv数据参数化：**多用户登录

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817155004363.png" alt="image-20250817155004151" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817155031233.png" alt="image-20250817155031067" style="zoom:50%;" />

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817160136642.png" alt="image-20250817155658324" style="zoom:50%;" />

#### 4.3 cookie管理器

Cookie 是一种在客户端（通常是浏览器）和服务器之间传递的小型文本文件，用于存储用户会话信息、偏好设置或其他数据。它在 Web 开发和网络应用中广泛使用，主要用于实现用户认证、会话管理、个性化体验等功能。

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817160753040.png" alt="image-20250817160752800" style="zoom:50%;" />



<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817153750394.png" alt="image-20250817153750137" style="zoom:50%;" />







#### 4.4 性能测试

**安装相应插件**：下载**[plugins-manager.jar](https://jmeter-plugins.org/get/)**并将其放入 `lib/ext` 中目录，然后重新启动 JMeter。



在选项中下划找到<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817162243048.png" alt="image-20250817162242860" style="zoom:50%;" />



**安装插件：page data extractor和custom thread group**最后效果如下：

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817162009714.png" alt="image-20250817162009495" style="zoom:50%;" />



**梯度压测：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817163358489.png" alt="image-20250817163358184" style="zoom: 33%;" />

**添加下面三个用于数据图表化监测**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817190957232.png" alt="image-20250817190957084" style="zoom:50%;" />

**活跃的线程数量**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817184716322.png" alt="image-20250817184716157" style="zoom:50%;" />



> **响应时间截图**从这张响应时间趋势图可以看出，系统在大部分接口上的表现都比较稳定，写博客、详情页、用户信息和登录接口的响应时间基本保持在毫秒级，波动很小，没有明显的性能问题；相比之下，博客列表页的响应时间明显偏高，整体在 2 到 8 秒之间波动，并且在测试过程中出现了多次尖峰，最高接近 20 秒，这说明在并发访问或数据量较大时，该接口容易成为系统性能瓶颈，可能与数据库查询效率、数据拼接逻辑复杂度或缓存机制不足有关。

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817191351750.png" alt="image-20250817191351542" style="zoom:50%;" />



**聚合报告显示**：系统的主要性能问题集中在 **博客列表页接口**，它不仅响应时间过长，还存在 100% 的错误率，几乎不可用；而其他接口性能相对较优，但也需要关注 10% 左右的错误比例。

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817185440969.png" alt="image-20250817185440786" style="zoom:50%;" />



**吞吐量：**

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817191556558.png" alt="image-20250817191556384" style="zoom:50%;" />

**响应时间和吞吐量的关系：响应时间高，吞吐量就低**：将两张图放在一起比对，在同一时间节点。呈现相反状态。





<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817192032926.png" alt="image-20250817192032671" style="zoom:50%;" />







**测试报告:**

在终端执行下面命令

`jmeter -n -t test_plan.jmx -l result.jtl -e -o ./report`

相关参数解读：

`-n`非 GUI 模式（headless 执行）。

`-t test_plan.jmx`指定 JMeter 脚本文件（测试计划）。

`-l result.jtl`指定结果日志文件（JTL 格式，保存原始请求数据）。

`-e`告诉 JMeter 在执行完成后生成 HTML 报告。

`-o ./report`指定报告输出目录（必须是 **不存在的空目录**，否则会报错）。



对于我本地的执行命令示例如下：

`jmeter -n -t "E:\软件测试开发课程\jmeter测试\博客系统测试.jmx" -l "E:\软件测试开发课程\jmeter测试\result.jtl" -e -o "E:\软件测试开发课程\jmeter测试\report"`

![image-20250817192634203](https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817192634539.png)



![image-20250817192700180](https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817192700469.png)

![image-20250817192718803](https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817192719010.png)

以及其他图表：

<img src="https://pookies-1314340089.cos.ap-singapore.myqcloud.com/imgs/20250817192821935.png" alt="image-20250817192821706" style="zoom:50%;" />
